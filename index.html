<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rafal Cobra</title>
  <!-- Importa a fonte Lilita One do Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Lilita+One&display=swap" rel="stylesheet">
  <style>
    /* Aplica a fonte a todos os elementos */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      font-family: 'Lilita One', cursive;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      background: #000;
      height: 100vh;
    }
    /* Container do jogo com tamanho definido dinamicamente */
    #game-container {
      position: relative;
    }
    /* Os canvases ocuparão 100% do container */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      transition: opacity 1s ease;
    }
    #backgroundCanvas { 
      z-index: 1; 
      opacity: 1; 
    }
    #gameCanvas { 
      z-index: 2; 
      opacity: 0; 
    }
    /* Ao iniciar o jogo, alterna as opacidades */
    #game-container.playing #backgroundCanvas { opacity: 0; }
    #game-container.playing #gameCanvas { opacity: 1; }
    
    /* Placar visível sempre sobre o container */
    #scoreboard {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      color: #fff;
      font-size: 3vh;
      background: rgba(0, 0, 0, 0.5);
      padding: 4px 8px;
      border-radius: 5px;
    }
    
    /* Tela de Game Over sobre o container, inicialmente oculta */
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #gameOverScreen h1 {
      font-size: 6vh;
      margin: 0;
    }
    #gameOverScreen p {
      font-size: 3vh;
      margin: 10px 0;
    }
    #gameOverScreen button {
      padding: 10px 20px;
      font-size: 3vh;
      margin-top: 20px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    
    /* Controles posicionados abaixo do jogo */
    #controls {
      display: flex;
      margin-top: 20px;
    }
    #controls button {
      margin: 0 5px;
      padding: 0.5em 1em;
      font-size: 2vh;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #controls button:disabled {
      opacity: 0.5;
      cursor: default;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="scoreboard">Score: <span id="score">0</span></div>
    <!-- Canvas do fundo (imagem inicial) -->
    <canvas id="backgroundCanvas"></canvas>
    <!-- Canvas do jogo (fundo cinza após iniciar) -->
    <canvas id="gameCanvas"></canvas>
    <!-- Tela de Game Over -->
    <div id="gameOverScreen">
      <h1>Game Over!</h1>
      <p>Score: <span id="finalScore"></span></p>
      <button id="gameOverRestartBtn">Restart</button>
    </div>
  </div>
  <div id="controls">
    <button id="startBtn">Play</button>
    <button id="pauseBtn" disabled>Pause</button>
    <button id="restartBtn" disabled>Restart</button>
  </div>

  <script>
    const bgCanvas = document.getElementById('backgroundCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const gameCanvas = document.getElementById('gameCanvas');
    const ctx = gameCanvas.getContext('2d');
    const container = document.getElementById('game-container');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const tileCount = 20; // Grade de 20 tiles
    let snake = [];
    let velocity = { x: 0, y: 0 };
    let apple = { x: 0, y: 0 };
    let score = 0;
    let gameLoop = null;

    // Imagens
    const backgroundImg = new Image();
    backgroundImg.src =
      'https://media.discordapp.net/attachments/1310983426488274987/1373339971318054984/Screenshot_20250414_152127_Gallery.jpg?ex=6833f144&is=68329fc4&hm=5bd4dac3746af61cf5706444daccb5e8b93aeacb37ceea2830c29f1fac708914&=&format=webp&width=1260&height=756';
    const snakeImg = new Image();
    snakeImg.src = backgroundImg.src;
    const foodImg = new Image();
    foodImg.src =
      'https://media.discordapp.net/attachments/1326527256532746302/1375603066434228244/IMG_2161.png?ex=683443f0&is=6832f270&hm=5523cd4f5da5c5026d762309410ff13eaef4a20ec413e1166be81075af848853&=&format=webp&quality=lossless&width=908&height=912';

    function resizeCanvas() {
      const controls = document.getElementById('controls');
      const availableWidth = window.innerWidth;
      const availableHeight = window.innerHeight - controls.offsetHeight - 20;
      let newSize;

      if (document.fullscreenElement) {
        // Em tela cheia, ocupar o maior quadrado possível
        newSize = Math.min(window.innerWidth, window.innerHeight);
      } else {
        // Em modo janela, usar cerca de 90% da menor dimensão disponível
        newSize = Math.floor(Math.min(availableWidth, availableHeight) * 0.9);
      }
      container.style.width = newSize + "px";
      container.style.height = newSize + "px";
      bgCanvas.width = newSize;
      bgCanvas.height = newSize;
      gameCanvas.width = newSize;
      gameCanvas.height = newSize;
      drawInitialBackground();
      drawGame();
    }

    window.addEventListener("resize", resizeCanvas);

    function drawInitialBackground() {
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      bgCtx.drawImage(backgroundImg, 0, 0, bgCanvas.width, bgCanvas.height);
    }

    function placeApple() {
      apple.x = Math.floor(Math.random() * tileCount);
      apple.y = Math.floor(Math.random() * tileCount);
      if (snake.some(seg => seg.x === apple.x && seg.y === apple.y)) placeApple();
    }

    function collision(head) {
      return snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y);
    }

    function drawGame() {
      let gridSize = gameCanvas.width / tileCount;
      ctx.fillStyle = '#888';
      ctx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);
      // Desenha a comida
      ctx.drawImage(foodImg, apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);
      // Desenha cada segmento da cobra
      snake.forEach(seg => {
        ctx.drawImage(snakeImg, seg.x * gridSize, seg.y * gridSize, gridSize, gridSize);
      });
    }

    function startGame() {
      // Esconde o overlay de Game Over, se estiver visível
      gameOverScreen.style.display = "none";
      snake = [{ x: 10, y: 10 }];
      velocity = { x: 0, y: 0 };
      score = 0;
      document.getElementById('score').textContent = score;
      placeApple();
      drawInitialBackground();
      drawGame();
      container.classList.add('playing');
      document.getElementById('startBtn').disabled = true;
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('restartBtn').disabled = false;
    }

    function beginMovement(e) {
      const key = e.key;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(key)) {
        if (velocity.x === 0 && velocity.y === 0) {
          switch(key) {
            case 'ArrowUp': velocity = { x: 0, y: -1 }; break;
            case 'ArrowDown': velocity = { x: 0, y: 1 }; break;
            case 'ArrowLeft': velocity = { x: -1, y: 0 }; break;
            case 'ArrowRight': velocity = { x: 1, y: 0 }; break;
          }
          document.addEventListener('keydown', changeDirection);
          gameLoop = setInterval(gameTick, 100);
        }
      }
    }

    function changeDirection(e) {
      const key = e.key;
      if (key === 'ArrowUp' && velocity.y !== 1) velocity = { x: 0, y: -1 };
      if (key === 'ArrowDown' && velocity.y !== -1) velocity = { x: 0, y: 1 };
      if (key === 'ArrowLeft' && velocity.x !== 1) velocity = { x: -1, y: 0 };
      if (key === 'ArrowRight' && velocity.x !== -1) velocity = { x: 1, y: 0 };
    }

    function gameTick() {
      const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };
      snake.unshift(head);
      if (head.x === apple.x && head.y === apple.y) {
        score++;
        document.getElementById('score').textContent = score;
        placeApple();
      } else {
        snake.pop();
      }
      
      if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || collision(head)) {
        clearInterval(gameLoop);
        // Exibe a tela de Game Over com o placar final
        finalScoreEl.textContent = score;
        gameOverScreen.style.display = "flex";
        document.getElementById('pauseBtn').disabled = true;
        return;
      }
      drawGame();
    }

    // Botões de controle
    document.getElementById('startBtn').addEventListener('click', () => {
      resizeCanvas();
      startGame();
    });
    document.getElementById('pauseBtn').addEventListener('click', () => {
      if (gameLoop) { clearInterval(gameLoop); gameLoop = null; }
    });
    document.getElementById('restartBtn').addEventListener('click', startGame);
    
    // Botão de restart da tela de Game Over
    document.getElementById('gameOverRestartBtn').addEventListener('click', startGame);
    
    document.addEventListener('keydown', beginMovement);

    backgroundImg.onload = () => resizeCanvas();
  </script>
</body>
</html>
